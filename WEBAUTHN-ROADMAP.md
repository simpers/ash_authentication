# SPDX-FileCopyrightText: 2022 Alembic Pty Ltd
#
# SPDX-License-Identifier: MIT

# WebAuthn Strategy Roadmap (AshAuthentication)

> Goal: deliver an MVP WebAuthn/passkeys strategy in small, reviewable PRs.
>
> This file is intentionally a checklist so we can tick items off as we go.

## Current Status (as of now)

- [x] Basic scaffolding exists in `AshAuthentication.Strategy.WebAuthn` (DSL, strategy protocol impl, plug module)
- [x] A `WebAuthnKey` Spark extension exists (placeholder)
- [x] Example wiring exists in `test/support/example/*` (user + key resource)

### Known gaps / issues to address early

- [x] Fix `WebAuthn.Transformer` bug: `maybe_set_register_action_name/1` sets the wrong field
- [x] Fix WebAuthn strategy protocol `tokens_required?/1` (currently references non-existent fields)
- [x] Clean up copy/paste issues (typespecs and docs referencing Password)
- [x] Align `WebAuthn.Plug` with actual WebAuthn phases (remove/adjust reset-related code)
- [x] Decide what to do about `AshAuthentication.Type.CoseKey`:
  - [x] Guard optional dependency usage (`:cbor` is optional) — check added to `WebAuthnKey.Verifier`
  - [x] Fix decode/cast behavior to return decoded term (or remove if not used)

### PR 3 Complete ✅

- [x] Defined `WebAuthnKey` resource contract with required attributes:
  - [x] `credential_id` (binary, unique)
  - [x] `public_key` (binary)
  - [x] `sign_count` (integer)
- [x] Added relationship to user (`belongs_to`)
- [x] Created `WebAuthnKey.Info` module for DSL introspection
- [x] Implemented transformer to auto-generate required attributes
- [x] Implemented verifier to validate resource contract
- [x] Added optional fields (`aaguid`, `transports`, `last_used_at`)
- [x] Chose Option B: enforce contract via verifiers (MVP-friendly)
- [x] Removed `user_handle` (belongs on User resource for discoverable credentials)
- [x] Updated DSL schema with WebAuthn-specific field names and comprehensive documentation

---

## MVP Definition (what “usable” means)

The MVP should allow:

- [ ] **Register a credential** for an *existing* user (user already created via password/OAuth/etc.)
- [ ] **Sign in** using WebAuthn and receive the same authentication result semantics as other strategies (token in metadata when enabled, etc.)
- [ ] **Persist** credential material in a `key_resource` and use it to authenticate later
- [ ] Core security validation:
  - [ ] challenge binding
  - [ ] rpId/origin validation (as supported by chosen library)
  - [ ] signature verification
  - [ ] sign_count updates (or a documented approach if the library handles it differently)

Explicitly non-MVP / can be deferred:

- [ ] Account creation purely via passkey (no other identity)
- [ ] Attestation trust chain / “trusted authenticators” policy
- [ ] Full device management UX
- [ ] Advanced enterprise attestation and platform-specific policies

---

## Proposed Strategy Shape (MVP)

WebAuthn is inherently multi-step. MVP should use **begin/finish phases**.

### Proposed phases

- [x] `:register_begin`
- [x] `:register_finish`
- [x] `:sign_in_begin`
- [x] `:sign_in_finish`

Notes:

- [ ] “Begin” endpoints return `PublicKeyCredential*Options` plus a signed state token.
- [ ] “Finish” endpoints verify the client response using the signed state token and return `{:ok, user}`.

---

## PR Plan (small, digestible increments)

### PR 1 — Make the existing scaffolding safe ✅

**Goal:** eliminate runtime traps and obvious correctness issues so we can build forward.

- [x] Fix `WebAuthn.Transformer` register action naming
- [x] Remove/fix `tokens_required?/1` for WebAuthn
- [x] Fix typespec mistakes / copy-paste issues
- [x] Align `WebAuthn.Plug` with actual phases
- [x] Ensure compilation succeeds cleanly
- [x] Add minimal tests asserting:
  - [x] DSL transform produces correct action names
  - [x] Strategy protocol functions don't crash (routes, phases, etc.)

**Exit criteria:** clean compile + WebAuthn modules are internally consistent. ✅

---

### PR 2 — Choose and isolate the WebAuthn crypto/verification implementation ✅

**Goal:** pick a WebAuthn library and hide it behind a stable internal adapter.

- [x] Choose underlying WebAuthn lib (`wax_` library)
- [x] Add a narrow boundary module, `AshAuthentication.WebAuthn.Adapter` behaviour
- [x] Provide a default adapter implementation (`WaxAdapter`)
- [x] Establish how we represent and validate:
  - [x] rpId (via DSL `rp_id` option)
  - [x] origin (via DSL `origin` option passed to adapter)
  - [x] challenge (raw bytes generated by wax_)
  - [x] user handle / discoverable credentials (deferred to later PR)
- [x] Add unit tests with fixtures and/or adapter mocks
- [x] Add compile-time checks for `:cbor` and `:wax_` dependencies

**Exit criteria:** we can generate options and verify responses through the adapter API. ✅

---

### PR 3 — Define the `WebAuthnKey` resource contract (data model MVP) ✅

**Goal:** formalize what `key_resource` must store and validate it.

Minimum required fields:

- [x] `credential_id` (binary) unique
- [x] `public_key` (binary; COSE or library-defined)
- [x] `sign_count` (integer)
- [x] Relationship to user (`belongs_to :user, …`) and a usable foreign key

Optional but recommended fields:

- [x] `aaguid`
- [x] `transports`
- [x] `last_used_at`
- [x] `user_handle` (REMOVED - belongs on User resource for discoverable credentials)

Implementation decisions made:

- [x] Chose **Option B**: enforce a contract via verifiers (MVP-friendly)
- [x] Created `AshAuthentication.WebAuthnKey.Info` module for DSL introspection
- [x] Transformer auto-generates required attributes (like TokenResource)
- [x] Verifier validates:
  - [x] Required attributes exist with correct types
  - [x] User relationship exists
  - [x] Unique identity on `credential_id`
  - [x] Optional dependencies (`:cbor`, `:wax_`) are present

**Exit criteria:** the strategy can reliably look up a credential and resolve its user. ✅

---

### PR 4 — Implement begin/finish phases + routes + plugs

**Goal:** deliver a functional HTTP + action interface.

- [ ] Implement strategy phases/actions:
  - [ ] `register_begin`
  - [ ] `register_finish`
  - [ ] `sign_in_begin`
  - [ ] `sign_in_finish`
- [ ] Implement plug handlers for each phase (patterned after Password)
- [ ] Decide the request/response shapes:
  - [ ] begin returns: options + signed `state`
  - [ ] finish accepts: client credential + `state`
- [ ] Implement the signed state token format (must include at least challenge + expiry)
  - [ ] Decide where signing happens (Jwt vs dedicated signer)
  - [ ] Ensure short expiry + replay protection where feasible

**Exit criteria:** a client can complete the full WebAuthn registration and login loop.

---

### PR 5 — Identity-required vs discoverable credentials (scope control)

**Goal:** pick a first supported sign-in mode.

Recommended order:

- [ ] MVP: implement `require_identity? == true`
  - [ ] `sign_in_begin` requires identity
  - [ ] server restricts `allowCredentials` to that user’s credential IDs
- [ ] Follow-up: implement discoverable (`require_identity? == false`)
  - [ ] `sign_in_begin` can omit identity
  - [ ] `sign_in_finish` finds the user from `credential_id`

**Exit criteria:** at least one sign-in mode is fully functional and tested.

---

### PR 6 — Tests proving correctness

**Goal:** comprehensive tests without needing browser JS.

- [ ] Unit tests:
  - [ ] state token signing/expiry validation
  - [ ] adapter wrapper behavior (mocked)
- [ ] Strategy tests:
  - [ ] begin returns options + state
  - [ ] finish persists key and returns user
  - [ ] sign_in_finish updates sign_count and/or last_used_at
- [ ] DSL verifier tests:
  - [ ] missing config produces helpful errors
  - [ ] missing attributes/relationship in key_resource is reported

**Exit criteria:** tests cover the happy path and key failure modes.

---

### PR 7 — Minimal docs and example wiring

**Goal:** make it straightforward for app developers to adopt.

- [ ] Document:
  - [ ] required user DSL config
  - [ ] required `key_resource` schema/contract
  - [ ] endpoint sequence (begin → browser API → finish)
  - [ ] suggested frontend tooling (e.g. SimpleWebAuthn)
- [ ] Ensure the `test/support/example` demonstrates a valid setup

**Exit criteria:** a developer can implement WebAuthn in their app with reasonable effort.

---

## Open Questions / Decisions (track here)

## Open Questions / Decisions (track here)

- [x] Which underlying WebAuthn library will we use? → `wax_`
- [ ] How will we sign and validate the begin/finish "state" token? → (pending PR 4)
- [x] What should the minimal required `key_resource` fields be for our chosen library? → credential_id, public_key, sign_count + user relationship
- [x] Do we want to auto-generate parts of the key resource (extension transformer) or enforce a contract (verifier-only) for MVP? → Auto-generate + verify (hybrid approach)
- [ ] What's the default stance on `require_identity?`? → (pending PR 5)
- [ ] How should state tokens be structured and signed in begin/finish phases?